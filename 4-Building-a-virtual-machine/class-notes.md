## Building a virtual machine

- Haskell has a lot of abstractions

- MIPS is a RISC?
- VMs are flexible, but you pay a performance penalty
- Once you've generated bytecode for Java, it can be run on any machine that has
  Java installed
- JIT compilation: compiles code to be native on the machine
  - compiling DURING executing, not before. During run-time. Bytecode
    translation to machine code.
- The `jump table` is a way to speed up a really long `switch()` statement,
  since that could be slow to check every single condition.
- Word == 2 bytes
- A python list will take very much more memory than just 1 byte per value.
  Unlike C, where if you're referring to a pointer array, each element will take
  exactly one byte.
- Two games to check out:

  - Silicon Zeros
  - Turing Complete
  - Szhenzen I/O
  - TIS-100

- Stack based VM `stack` is not the same as the call stack
- stack based VM:

```
x = pop()
y = pop()
push(x + y)
```

- This is a todo for next time:
  | type | pros | cons |
  | -------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ---- |
  | register-based VM | higher performance possibly becuase with the stack you're constantly moving things in and out of the stack just to do operations | |
  | stack based-based VM | | |

- **Byte**code is what runs on a virtual machine
  - So, when you write a Python program and check out the byte code for it, that
    byte code is what is sent to the Python virtual machine (a program like the
    one you wrote for this week)
- **Machine** code is what is sent to the actual machine!!!
